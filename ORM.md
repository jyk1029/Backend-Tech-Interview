# ORM? (Object-Relational Mapping)
- 클래스와 RDB에서 쓰이는 데이터인 테이블을 매핑하는 것
- ORM을 이용하면 SQL Query가 아닌 직관적인 코드(메소드)로서 데이터를 조작

## 패러다임 불일치
- **```세분성(Granularity)```** : 데이터베이스에 있는 테이블 수보다 더 많은 클래스를 가진 모델이 생길 가능성 O
  - 객체 모델이 관계형 모델보다 더 세분화
- **```상속성(Inheritance)```** : RDBMS는 객체지향 프로그래밍 언어의 특징인 상속 개념 X
  - 상속, 연관 등이 사용되면 객체와 테이블을 매칭 하는 것이 굉장히 복잡 (많은 테이블을 조인해야 하는 경우가 다반사)
- **```동일성(Indentity)```** : RDBMS는 기본키(primary key)를 이용하여 동일성을 정의 vs 자바는 객체 식별(a==b) 과 객체 동일성(a.equals(b)) 을 모두 정의
- **```연관성(Association)```** : 관계형 데이터 베이스에서는 외래 키(Foreign Key, FK)를 사용해 양방향 참조 vs객체 지향 언어의 객체 참조는 단방향 참조
- **```탐색(Navigation)```** : 데이터를 탐색하는 방법
  - RDBMS는 SQL을 최소화하기위해 조인을 통해 여러 엔티티을 불러와서 데이터를 탐색 vs 자바는 하나의 객체에서 출발해 연결을 따라 그래프 형태로 탐색 (RDBMS의 경우 검색하고자 하는 테이블과 멤버가 있는지 확인을 하고 사용해야하는 제약)

## 장점
- ### 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중
  - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 ⬇️
  - 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성 ⬆️
  - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인한 생산성 증가
- ### 재사용 및 유지보수의 편리성 증가
  - ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용
  - 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리
  - 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도 ⬇️
- ### DBMS에 대한 종속성 ⬇️
  - 대부분 ORM 솔루션은 DB에 종속적 X
  - 종속적이지 않다는것은 구현 방법 뿐만 아니라 많은 솔루션에서 자료형 타입까지 유효
  - 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간 소요 
  - 자바에서 가공할경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공 O

## 단점
- ### 완벽한 ORM 으로만 서비스를 구현하기 어려움
  - 사용하기는 편하지만 설계는 매우 신중하게 해야함
  - 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 가능성 O 
  - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 가능성 O 
  - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우 O 
  - DBMS의 고유 기능을 이용하기 어려움 (이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성 ⬇️)
- ### 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어려움
  - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생 가능성 O




